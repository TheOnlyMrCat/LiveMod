# livemod - Runtime modification of program values

Livemod is my attempt to make Unity-style runtime parameter modification possible in Rust.

## Usage

Livemod requires the library, `livemod`, and a locally-installed viewer, such as `livemod-gui`.

`livemod-gui` can be installed through `cargo`:

```
cargo install livemod-gui
```

And can be used from your code by:

```rs
let livemod = LiveModHandle::new_gui();

let tracked_variable = livemod.create_variable("My variable", 0_u32);
```

### Using `#[derive]`

The `LiveMod` trait can be `#[derive]`d if the feature `derive` is enabled (Currently only on structs with named fields,
but support for tuple structs, enums, and unions is planned). The behaviour of the derive macro can be modified with the
`#[livemod]` field attribute, the behaviour of which is documented below:

#### `#[livemod(skip)]`: Skip representing a field

The field will not be modifiable by `livemod`, and will not be required to implement the `LiveMod` trait.

#### `#[livemod(rename = "New name")]` Rename a field

The field will be labelled with the new name. By default, a field's label is generated by capitalising the first letter of its
name and replacing underscores with spaces.

#### `#[livemod(repr = Trait(args))]` Change the representation of a field

Instead of calling `LiveMod::data_type()` on the field's type to determine its representation, use its definition of the
supplied trait instead.

For example, integers and floats implement the `Slider` trait, and can be used as follows:

```rs
#[livemod(repr = Slider(0..=100))]
field: u32
```